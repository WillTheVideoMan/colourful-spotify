{"version":3,"sources":["palettify.js","main.js"],"names":["$","local_track","is_active_device","error_state","first_load","position_ticker","prev_time","Date","now","token","background","window","setInterval","ajax","url","type","complete","xhr","textStatus","status","location","reload","handle_error","angle","rotation_velocity","background_opacity","rotator_ticker","controls_hidden","inactivity_timer","setTimeout","hide_controls","update_track_UI","artists_string","artists","name","length","i","text","attr","art_url","ms_to_string","duration","prop","paused","html","update_controls_UI","position","val","reset_player","id","features","tempo","energy","loudness","valence","palette","console","log","pause_tickers","set_background_features","update_background","player_ready","device_id","animate","bottom","css","resume_tickers","update_position","clearInterval","ms","string_time","hour","parseInt","min","toString","sec","error","message","Number","toPrecision","document","body","opacity","onSpotifyWebPlaybackSDKReady","player","Spotify","Player","getOAuthToken","cb","done","get","data","reason","access_token","getToken","new_token","addListener","state","track_window","current_track","new_track","album","images","duration_ms","image_url","colour_count","track_object","audio_features_url","beforeSend","setRequestHeader","success","get_features_from_track","img","Image","crossOrigin","src","onload","image","paletteFromImage","update_track","warn","click","togglePlay","then","previousTrack","nextTrack","on","seek","connect","mousemove","clearTimeout","stop","pv","map","array","f","o","d","index","call","slice","naturalOrder","a","b","sum","reduce","p","max","Math","apply","MMCQ","sigbits","rshift","maxIterations","fractByPopulations","getColorIndex","r","g","PQueue","comparator","contents","sorted","sort","push","peek","undefined","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","this","CMap","vboxes","vbox","count","volume","medianCutApply","rw","gw","bw","maxw","copy","j","k","total","partialsum","lookaheadsum","forEach","doCut","color","left","right","vbox1","vbox2","d2","dim1","dim2","count2","prototype","force","_volume","_count_set","npix","_count","avg","_avg","hval","ntot","mult","rsum","gsum","bsum","contains","pixel","rval","gval","bval","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","quantize","pixels","maxcolors","Array","getHisto","rmin","rmax","gmin","gmax","bmin","bmax","vboxFromPixels","pq","iter","lh","target","ncolors","niters","pq2","cmap","maxColours","offset","CanvasImage","getImageData","pixelCount","getPixelCount","pixelArray","removeCanvas","canvas","createElement","context","getContext","appendChild","width","height","drawImage","parentNode","removeChild"],"mappings":"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","file":"bundle.min.js","sourcesContent":["/*\r\n  palettify.js (for browsers) : Adapted from quantize.js\r\n  Provides quick palette generation with direct image input\r\n  without the need for first getting cmap, for simpler operation.\r\n  Utilises the HTML CANVAS API for pixel array genertation.\r\n\r\n*/\r\n\r\n/*!\r\n * quantize.js Copyright 2008 Nick Rabinowitz.\r\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\r\n */\r\n\r\n// fill out a couple protovis dependencies\r\n/*!\r\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\r\n * Copyright 2010 Stanford Visualization Group\r\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\r\n */\r\nif (!pv) {\r\n  var pv = {\r\n    map: function(array, f) {\r\n      var o = {};\r\n      return f ?\r\n        array.map(function(d, i) {\r\n          o.index = i;\r\n          return f.call(o, d);\r\n        }) :\r\n        array.slice();\r\n    },\r\n    naturalOrder: function(a, b) {\r\n      return (a < b) ? -1 : ((a > b) ? 1 : 0);\r\n    },\r\n    sum: function(array, f) {\r\n      var o = {};\r\n      return array.reduce(f ?\r\n        function(p, d, i) {\r\n          o.index = i;\r\n          return p + f.call(o, d);\r\n        } :\r\n        function(p, d) {\r\n          return p + d;\r\n        }, 0);\r\n    },\r\n    max: function(array, f) {\r\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Basic Javascript port of the MMCQ (modified median cut quantization)\r\n * algorithm from the Leptonica library (http://www.leptonica.com/).\r\n * Returns a color map you can use to map original pixels to the reduced\r\n * palette. Still a work in progress.\r\n *\r\n * @author Nick Rabinowitz\r\n * @example\r\n// array of pixels as [R,G,B] arrays\r\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\r\n                // etc\r\n                ];\r\nvar maxColors = 4;\r\nvar cmap = MMCQ.quantize(myPixels, maxColors);\r\nvar newPalette = cmap.palette();\r\nvar newPixels = myPixels.map(function(p) {\r\n    return cmap.map(p);\r\n});\r\n\r\n */\r\nvar MMCQ = (function() {\r\n  // private constants\r\n  var sigbits = 5,\r\n    rshift = 8 - sigbits,\r\n    maxIterations = 1000,\r\n    fractByPopulations = 0.75;\r\n\r\n  // get reduced-space color index for a pixel\r\n  function getColorIndex(r, g, b) {\r\n    return (r << (2 * sigbits)) + (g << sigbits) + b;\r\n  }\r\n\r\n  // Simple priority queue\r\n  function PQueue(comparator) {\r\n    var contents = [],\r\n      sorted = false;\r\n\r\n    function sort() {\r\n      contents.sort(comparator);\r\n      sorted = true;\r\n    }\r\n\r\n    return {\r\n      push: function(o) {\r\n        contents.push(o);\r\n        sorted = false;\r\n      },\r\n      peek: function(index) {\r\n        if (!sorted) sort();\r\n        if (index === undefined) index = contents.length - 1;\r\n        return contents[index];\r\n      },\r\n      pop: function() {\r\n        if (!sorted) sort();\r\n        return contents.pop();\r\n      },\r\n      size: function() {\r\n        return contents.length;\r\n      },\r\n      map: function(f) {\r\n        return contents.map(f);\r\n      },\r\n      debug: function() {\r\n        if (!sorted) sort();\r\n        return contents;\r\n      }\r\n    };\r\n  }\r\n\r\n  // 3d color space box\r\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\r\n    var vbox = this;\r\n    vbox.r1 = r1;\r\n    vbox.r2 = r2;\r\n    vbox.g1 = g1;\r\n    vbox.g2 = g2;\r\n    vbox.b1 = b1;\r\n    vbox.b2 = b2;\r\n    vbox.histo = histo;\r\n  }\r\n  VBox.prototype = {\r\n    volume: function(force) {\r\n      var vbox = this;\r\n      if (!vbox._volume || force) {\r\n        vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\r\n      }\r\n      return vbox._volume;\r\n    },\r\n    count: function(force) {\r\n      var vbox = this,\r\n        histo = vbox.histo;\r\n      if (!vbox._count_set || force) {\r\n        var npix = 0,\r\n          i, j, k;\r\n        for (i = vbox.r1; i <= vbox.r2; i++) {\r\n          for (j = vbox.g1; j <= vbox.g2; j++) {\r\n            for (k = vbox.b1; k <= vbox.b2; k++) {\r\n              index = getColorIndex(i, j, k);\r\n              npix += (histo[index] || 0);\r\n            }\r\n          }\r\n        }\r\n        vbox._count = npix;\r\n        vbox._count_set = true;\r\n      }\r\n      return vbox._count;\r\n    },\r\n    copy: function() {\r\n      var vbox = this;\r\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\r\n    },\r\n    avg: function(force) {\r\n      var vbox = this,\r\n        histo = vbox.histo;\r\n      if (!vbox._avg || force) {\r\n        var ntot = 0,\r\n          mult = 1 << (8 - sigbits),\r\n          rsum = 0,\r\n          gsum = 0,\r\n          bsum = 0,\r\n          hval,\r\n          i, j, k, histoindex;\r\n        for (i = vbox.r1; i <= vbox.r2; i++) {\r\n          for (j = vbox.g1; j <= vbox.g2; j++) {\r\n            for (k = vbox.b1; k <= vbox.b2; k++) {\r\n              histoindex = getColorIndex(i, j, k);\r\n              hval = histo[histoindex] || 0;\r\n              ntot += hval;\r\n              rsum += (hval * (i + 0.5) * mult);\r\n              gsum += (hval * (j + 0.5) * mult);\r\n              bsum += (hval * (k + 0.5) * mult);\r\n            }\r\n          }\r\n        }\r\n        if (ntot) {\r\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\r\n        } else {\r\n          console.log('empty box');\r\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\r\n        }\r\n      }\r\n      return vbox._avg;\r\n    },\r\n    contains: function(pixel) {\r\n      var vbox = this,\r\n        rval = pixel[0] >> rshift;\r\n      gval = pixel[1] >> rshift;\r\n      bval = pixel[2] >> rshift;\r\n      return (rval >= vbox.r1 && rval <= vbox.r2 &&\r\n        gval >= vbox.g1 && rval <= vbox.g2 &&\r\n        bval >= vbox.b1 && rval <= vbox.b2);\r\n    }\r\n  };\r\n\r\n  // Color map\r\n  function CMap() {\r\n    this.vboxes = new PQueue(function(a, b) {\r\n      return pv.naturalOrder(\r\n        a.vbox.count() * a.vbox.volume(),\r\n        b.vbox.count() * b.vbox.volume()\r\n      )\r\n    });;\r\n  }\r\n  CMap.prototype = {\r\n    push: function(vbox) {\r\n      this.vboxes.push({\r\n        vbox: vbox,\r\n        color: vbox.avg()\r\n      });\r\n    },\r\n    palette: function() {\r\n      return this.vboxes.map(function(vb) {\r\n        return vb.color\r\n      });\r\n    },\r\n    size: function() {\r\n      return this.vboxes.size();\r\n    },\r\n    map: function(color) {\r\n      var vboxes = this.vboxes;\r\n      for (var i = 0; i < vboxes.size(); i++) {\r\n        if (vboxes.peek(i).vbox.contains(color)) {\r\n          return vboxes.peek(i).color;\r\n        }\r\n      }\r\n      return this.nearest(color);\r\n    },\r\n    nearest: function(color) {\r\n      var vboxes = this.vboxes,\r\n        d1, d2, pColor;\r\n      for (var i = 0; i < vboxes.size(); i++) {\r\n        d2 = Math.sqrt(\r\n          Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\r\n          Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\r\n          Math.pow(color[1] - vboxes.peek(i).color[1], 2)\r\n        );\r\n        if (d2 < d1 || d1 === undefined) {\r\n          d1 = d2;\r\n          pColor = vboxes.peek(i).color;\r\n        }\r\n      }\r\n      return pColor;\r\n    },\r\n    forcebw: function() {\r\n      // XXX: won't  work yet\r\n      var vboxes = this.vboxes;\r\n      vboxes.sort(function(a, b) {\r\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color))\r\n      });\r\n\r\n      // force darkest color to black if everything < 5\r\n      var lowest = vboxes[0].color;\r\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\r\n        vboxes[0].color = [0, 0, 0];\r\n\r\n      // force lightest color to white if everything > 251\r\n      var idx = vboxes.length - 1,\r\n        highest = vboxes[idx].color;\r\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\r\n        vboxes[idx].color = [255, 255, 255];\r\n    }\r\n  };\r\n\r\n  // histo (1-d array, giving the number of pixels in\r\n  // each quantized region of color space), or null on error\r\n  function getHisto(pixels) {\r\n    var histosize = 1 << (3 * sigbits),\r\n      histo = new Array(histosize),\r\n      index, rval, gval, bval;\r\n    pixels.forEach(function(pixel) {\r\n      rval = pixel[0] >> rshift;\r\n      gval = pixel[1] >> rshift;\r\n      bval = pixel[2] >> rshift;\r\n      index = getColorIndex(rval, gval, bval);\r\n      histo[index] = (histo[index] || 0) + 1;\r\n    });\r\n    return histo;\r\n  }\r\n\r\n  function vboxFromPixels(pixels, histo) {\r\n    var rmin = 1000000,\r\n      rmax = 0,\r\n      gmin = 1000000,\r\n      gmax = 0,\r\n      bmin = 1000000,\r\n      bmax = 0,\r\n      rval, gval, bval;\r\n    // find min/max\r\n    pixels.forEach(function(pixel) {\r\n      rval = pixel[0] >> rshift;\r\n      gval = pixel[1] >> rshift;\r\n      bval = pixel[2] >> rshift;\r\n      if (rval < rmin) rmin = rval;\r\n      else if (rval > rmax) rmax = rval;\r\n      if (gval < gmin) gmin = gval;\r\n      else if (gval > gmax) gmax = gval;\r\n      if (bval < bmin) bmin = bval;\r\n      else if (bval > bmax) bmax = bval;\r\n    });\r\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\r\n  }\r\n\r\n  function medianCutApply(histo, vbox) {\r\n    if (!vbox.count()) return;\r\n\r\n    var rw = vbox.r2 - vbox.r1 + 1,\r\n      gw = vbox.g2 - vbox.g1 + 1,\r\n      bw = vbox.b2 - vbox.b1 + 1,\r\n      maxw = pv.max([rw, gw, bw]);\r\n    // only one pixel, no split\r\n    if (vbox.count() == 1) {\r\n      return [vbox.copy()]\r\n    }\r\n    /* Find the partial sum arrays along the selected axis. */\r\n    var total = 0,\r\n      partialsum = [],\r\n      lookaheadsum = [],\r\n      i, j, k, sum, index;\r\n    if (maxw == rw) {\r\n      for (i = vbox.r1; i <= vbox.r2; i++) {\r\n        sum = 0;\r\n        for (j = vbox.g1; j <= vbox.g2; j++) {\r\n          for (k = vbox.b1; k <= vbox.b2; k++) {\r\n            index = getColorIndex(i, j, k);\r\n            sum += (histo[index] || 0);\r\n          }\r\n        }\r\n        total += sum;\r\n        partialsum[i] = total;\r\n      }\r\n    } else if (maxw == gw) {\r\n      for (i = vbox.g1; i <= vbox.g2; i++) {\r\n        sum = 0;\r\n        for (j = vbox.r1; j <= vbox.r2; j++) {\r\n          for (k = vbox.b1; k <= vbox.b2; k++) {\r\n            index = getColorIndex(j, i, k);\r\n            sum += (histo[index] || 0);\r\n          }\r\n        }\r\n        total += sum;\r\n        partialsum[i] = total;\r\n      }\r\n    } else { /* maxw == bw */\r\n      for (i = vbox.b1; i <= vbox.b2; i++) {\r\n        sum = 0;\r\n        for (j = vbox.r1; j <= vbox.r2; j++) {\r\n          for (k = vbox.g1; k <= vbox.g2; k++) {\r\n            index = getColorIndex(j, k, i);\r\n            sum += (histo[index] || 0);\r\n          }\r\n        }\r\n        total += sum;\r\n        partialsum[i] = total;\r\n      }\r\n    }\r\n    partialsum.forEach(function(d, i) {\r\n      lookaheadsum[i] = total - d\r\n    });\r\n\r\n    function doCut(color) {\r\n      var dim1 = color + '1',\r\n        dim2 = color + '2',\r\n        left, right, vbox1, vbox2, d2, count2 = 0;\r\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\r\n        if (partialsum[i] > total / 2) {\r\n          vbox1 = vbox.copy();\r\n          vbox2 = vbox.copy();\r\n          left = i - vbox[dim1];\r\n          right = vbox[dim2] - i;\r\n          if (left <= right)\r\n            d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));\r\n          else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\r\n          // avoid 0-count boxes\r\n          while (!partialsum[d2]) d2++;\r\n          count2 = lookaheadsum[d2];\r\n          while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\r\n          // set dimensions\r\n          vbox1[dim2] = d2;\r\n          vbox2[dim1] = vbox1[dim2] + 1;\r\n          //console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\r\n          return [vbox1, vbox2];\r\n        }\r\n      }\r\n\r\n    }\r\n    // determine the cut planes\r\n    return maxw == rw ? doCut('r') :\r\n      maxw == gw ? doCut('g') :\r\n      doCut('b');\r\n  }\r\n\r\n  function quantize(pixels, maxcolors) {\r\n    // short-circuit\r\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\r\n      console.log('wrong number of maxcolors');\r\n      return false;\r\n    }\r\n\r\n    // XXX: check color content and convert to grayscale if insufficient\r\n\r\n    var histo = getHisto(pixels),\r\n      histosize = 1 << (3 * sigbits);\r\n\r\n    // check that we aren't below maxcolors already\r\n    var nColors = 0;\r\n    histo.forEach(function() {\r\n      nColors++\r\n    });\r\n    if (nColors <= maxcolors) {\r\n      // XXX: generate the new colors from the histo and return\r\n    }\r\n\r\n    // get the beginning vbox from the colors\r\n    var vbox = vboxFromPixels(pixels, histo),\r\n      pq = new PQueue(function(a, b) {\r\n        return pv.naturalOrder(a.count(), b.count())\r\n      });\r\n    pq.push(vbox);\r\n\r\n    // inner function to do the iteration\r\n    function iter(lh, target) {\r\n      var ncolors = 1,\r\n        niters = 0,\r\n        vbox;\r\n      while (niters < maxIterations) {\r\n        vbox = lh.pop();\r\n        if (!vbox.count()) { /* just put it back */\r\n          lh.push(vbox);\r\n          niters++;\r\n          continue;\r\n        }\r\n        // do the cut\r\n        var vboxes = medianCutApply(histo, vbox),\r\n          vbox1 = vboxes[0],\r\n          vbox2 = vboxes[1];\r\n\r\n        if (!vbox1) {\r\n          console.log(\"vbox1 not defined; shouldn't happen!\");\r\n          return;\r\n        }\r\n        lh.push(vbox1);\r\n        if (vbox2) { /* vbox2 can be null */\r\n          lh.push(vbox2);\r\n          ncolors++;\r\n        }\r\n        if (ncolors >= target) return;\r\n        if (niters++ > maxIterations) {\r\n          console.log(\"infinite loop; perhaps too few pixels!\");\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // first set of colors, sorted by population\r\n    iter(pq, fractByPopulations * maxcolors);\r\n    // console.log(pq.size(), pq.debug().length, pq.debug().slice());\r\n\r\n    // Re-sort by the product of pixel occupancy times the size in color space.\r\n    var pq2 = new PQueue(function(a, b) {\r\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume())\r\n    });\r\n    while (pq.size()) {\r\n      pq2.push(pq.pop());\r\n    }\r\n\r\n    // next set - generate the median cuts using the (npix * vol) sorting.\r\n    iter(pq2, maxcolors - pq2.size());\r\n\r\n    // calculate the actual colors\r\n    var cmap = new CMap();\r\n    while (pq2.size()) {\r\n      cmap.push(pq2.pop());\r\n    }\r\n\r\n    return cmap;\r\n  }\r\n\r\n  return {\r\n    quantize: quantize\r\n  }\r\n})();\r\n\r\nfunction paletteFromImage(image, maxColours) {\r\n\r\n  // Create custom CanvasImage object\r\n  var image = new CanvasImage(image.target);\r\n  var imageData = image.getImageData();\r\n  var pixels = imageData.data;\r\n  var pixelCount = image.getPixelCount();\r\n\r\n  // Store the RGB values in an array format suitable for quantize function\r\n  var pixelArray = [];\r\n\r\n  // skip 1 in 4 pixels for a sparse sampling\r\n  for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + 4) {\r\n    offset = i * 4;\r\n    r = pixels[offset + 0];\r\n    g = pixels[offset + 1];\r\n    b = pixels[offset + 2];\r\n    a = pixels[offset + 3];\r\n    // If pixel is mostly opaque and not white\r\n    if (a >= 125) {\r\n      if (!(r > 250 && g > 250 && b > 250)) {\r\n        pixelArray.push([r, g, b]);\r\n      }\r\n    }\r\n  }\r\n  // Clean up\r\n  image.removeCanvas();\r\n\r\n  //Perform MMCQ and return the palette array.\r\n  var cmap = MMCQ.quantize(pixelArray, maxColours);\r\n  return cmap.palette();\r\n\r\n}\r\n\r\n//Custom CanvasImage object defenition.\r\nvar CanvasImage = function(image) {\r\n\r\n  //Define the canvas and context.\r\n  this.canvas = document.createElement('canvas');\r\n  this.context = this.canvas.getContext('2d');\r\n\r\n  //Append the canvas to the document body.\r\n  document.body.appendChild(this.canvas);\r\n\r\n  //Set dimensions.\r\n  this.width = this.canvas.width = image.width;\r\n  this.height = this.canvas.height = image.height;\r\n\r\n  //Draw the image to the canvas.\r\n  this.context.drawImage(image, 0, 0, this.width, this.height);\r\n};\r\n\r\n//Get the number of pixels.\r\nCanvasImage.prototype.getPixelCount = function() {\r\n  return this.width * this.height;\r\n};\r\n\r\n//Get the image data from the canvas.\r\nCanvasImage.prototype.getImageData = function() {\r\n  return this.context.getImageData(0, 0, this.width, this.height);\r\n};\r\n\r\n//Remove the canvas from the document body.\r\nCanvasImage.prototype.removeCanvas = function() {\r\n  this.canvas.parentNode.removeChild(this.canvas);\r\n};","$(function() {\r\n\r\n  //Playback and track info variables.\r\n  var local_track = {};\r\n  var is_active_device = false;\r\n  var error_state = false;\r\n  var first_load = true;\r\n  var position_ticker = null;\r\n  var prev_time = Date.now();\r\n  var token = \"\";\r\n  var online_pinger = window.setInterval(check_online, 5000);\r\n\r\n  //Background colour and rotation variables.\r\n  var background = $(\"#background\");\r\n  var angle = 0;\r\n  var rotation_velocity = 0.015;\r\n  var background_opacity = 0.75;\r\n  var rotator_ticker = null;\r\n  var activity_timeout = 2500;\r\n  var controls_hidden = false;\r\n  var inactivity_timer = window.setTimeout(hide_controls, activity_timeout);\r\n\r\n  //When Spotify is ready, initialize the player.\r\n  window.onSpotifyWebPlaybackSDKReady = () => {\r\n\r\n    //Define the Spotify player object instance.\r\n    const player = new Spotify.Player({\r\n      name: 'Colourful Player',\r\n      getOAuthToken: cb => {\r\n        //Define token update function.\r\n        getToken(function(new_token) {\r\n          cb(new_token);\r\n          token = new_token;\r\n        });\r\n      }\r\n    });\r\n\r\n    // Error handling\r\n    player.addListener('initialization_error', ({\r\n      message\r\n    }) => {\r\n      handle_error(\"init_err\");\r\n    });\r\n\r\n    player.addListener('authentication_error', ({\r\n      message\r\n    }) => {\r\n      handle_error(\"auth_err\");\r\n    });\r\n\r\n    player.addListener('account_error', ({\r\n      message\r\n    }) => {\r\n      handle_error(\"acc_err'\");\r\n    });\r\n\r\n    player.addListener('playback_error', ({\r\n      message\r\n    }) => {\r\n      handle_error(\"play_err\");\r\n    });\r\n\r\n    // Playback status updates\r\n    player.addListener('player_state_changed', state => {\r\n\r\n      //If the player is still the active playback device\r\n      if (state) {\r\n\r\n        //Ensure the player knows it is still the active device.\r\n        is_active_device = true;\r\n\r\n        //If the song has changed\r\n        if (state.track_window.current_track.id != local_track.id) {\r\n          //Update the local track.\r\n          update_track(state.track_window.current_track);\r\n        }\r\n\r\n        //If the song has been paused\r\n        if (state.paused && !local_track.paused) {\r\n          //update the local track paused state.\r\n          local_track.paused = true;\r\n          pause_tickers();\r\n        }\r\n\r\n        //If the song has been played\r\n        if (!state.paused && local_track.paused) {\r\n          //update the local track paused state.\r\n          local_track.paused = false;\r\n          resume_tickers();\r\n        }\r\n\r\n        //update the local track seek position.\r\n        local_track.position = state.position;\r\n\r\n      } else {\r\n\r\n        //No longer the active device.\r\n        is_active_device = false;\r\n        console.warn(\"No longer the active player!\");\r\n        reset_player();\r\n        player_ready();\r\n\r\n      }\r\n\r\n      //Repaint the the track UI with any new data.\r\n      update_track_UI();\r\n\r\n      //Repaint the controls UI with any new data;\r\n      update_controls_UI();\r\n\r\n    });\r\n\r\n    // Ready\r\n    player.addListener('ready', ({\r\n      device_id\r\n    }) => {\r\n      player_ready();\r\n      update_track_UI();\r\n      console.log('Ready with Device ID', device_id);\r\n    });\r\n\r\n    // Not Ready\r\n    player.addListener('not_ready', ({\r\n      device_id\r\n    }) => {\r\n      handle_error(\"device_offline\")\r\n      console.log('Device ID has gone offline', device_id);\r\n    });\r\n\r\n    //On Play/Pause event.\r\n    $(\"#play_pause\").click(function() {\r\n      if (is_active_device) {\r\n        player.togglePlay().then(() => {\r\n          console.log('Toggled playback!');\r\n        });\r\n      }\r\n    });\r\n\r\n    //On prev, handle.\r\n    $(\"#skip_prev\").click(function() {\r\n      if (is_active_device) {\r\n        player.previousTrack().then(() => {\r\n          console.log('Set to previous track!');\r\n        });\r\n      }\r\n    });\r\n\r\n    //On skip, handle.\r\n    $(\"#skip_next\").click(function() {\r\n      if (is_active_device) {\r\n        player.nextTrack().then(() => {\r\n          console.log('Skipped to next track!');\r\n        });\r\n      }\r\n    });\r\n\r\n    //On position slider mouse down, stop the tickers.\r\n    $(\"#track_position_slider\").on('mousedown', function() {\r\n      if (is_active_device) {\r\n        pause_tickers();\r\n      }\r\n    });\r\n\r\n    //On position slider movement, update the local track position and update the control UI.\r\n    $(\"#track_position_slider\").on('input', function() {\r\n      if (is_active_device) {\r\n        local_track.position = $(\"#track_position_slider\").val();\r\n        update_controls_UI();\r\n      }\r\n    });\r\n\r\n    //On position change, handle and resume tickers.\r\n    $(\"#track_position_slider\").on('change', function() {\r\n      if (is_active_device) {\r\n        player.seek($(\"#track_position_slider\").val()).then(() => {\r\n          console.log('Changed position!');\r\n          resume_tickers();\r\n        });\r\n      }\r\n    });\r\n\r\n    // Connect to the player!\r\n    player.connect();\r\n\r\n  };\r\n\r\n  //update the local_track object.\r\n  function update_track(new_track) {\r\n    local_track.id = new_track.id;\r\n    local_track.name = new_track.name;\r\n    local_track.art_url = new_track.album.images[2].url;\r\n    local_track.artists = new_track.artists;\r\n    local_track.duration = new_track.duration_ms;\r\n    local_track.type = new_track.type;\r\n\r\n    //generate a new palette;\r\n    get_palette_from_image(local_track.art_url, 6, function(palette) {\r\n      local_track.palette = palette;\r\n\r\n      //Get track features. Update the background.\r\n      get_features_from_track(local_track, function(features) {\r\n        local_track.features = features;\r\n        set_background_features(local_track.features);\r\n\r\n        //Update_background\r\n        update_background();\r\n\r\n      });\r\n\r\n    });\r\n\r\n    console.log(local_track);\r\n\r\n  }\r\n\r\n  //Repaint the UI elements of the track\r\n  function update_track_UI() {\r\n\r\n    if (!error_state) {\r\n      var artists_string = local_track.artists[0].name;\r\n\r\n      //If there is more than one artists, then append them to the string.\r\n      if (local_track.artists.length > 1) {\r\n        for (var i = 1; i < local_track.artists.length; i++) {\r\n          artists_string += \", \" + local_track.artists[i].name;\r\n        }\r\n      }\r\n\r\n      //Update DOM elements\r\n      $(\"#track_name\").text(local_track.name);\r\n      $(\"#track_artist\").text(artists_string);\r\n      $(\"#track_album_art\").attr(\"src\", local_track.art_url);\r\n      $(\"#track_time_duration\").text(ms_to_string(local_track.duration));\r\n      $(\"#track_position_slider\").prop('max', local_track.duration);\r\n\r\n      //Update play/pause button\r\n      if (!is_active_device) {\r\n        $(\"#play_pause\").html(\"remove_circle_outline\");\r\n      } else if (local_track.paused) {\r\n        $(\"#play_pause\").html(\"play_circle_outline\");\r\n      } else {\r\n        $(\"#play_pause\").html(\"pause_circle_outline\");\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  //Repaint the UI elements of the controls\r\n  function update_controls_UI() {\r\n\r\n    if (!error_state) {\r\n      //Update UI.\r\n      $(\"#track_time_position\").text(ms_to_string(local_track.position));\r\n      $(\"#track_position_slider\").val(local_track.position);\r\n    }\r\n\r\n  }\r\n\r\n  //Reset the player (for whatever reason)\r\n  function reset_player() {\r\n\r\n    //reset of the local track object.\r\n    local_track = {\r\n      \"id\": \"\",\r\n      \"name\": \"...\",\r\n      \"artists\": [{ \"name\": \"...\" }],\r\n      \"paused\": true,\r\n      \"position\": 0,\r\n      \"duration\": 0,\r\n      \"art_url\": \"/images/spotify-640x640.png\",\r\n      \"type\": \"\",\r\n      \"features\": {\r\n        \"tempo\": 50,\r\n        \"energy\": 0.5,\r\n        \"loudness\": 0.5,\r\n        \"valence\": 0.5\r\n      },\r\n      \"palette\": [\r\n        [36, 212, 92],\r\n        [209, 245, 221],\r\n        [112, 224, 151],\r\n        [139, 228, 172],\r\n        [84, 220, 132],\r\n        [73, 216, 121]\r\n      ]\r\n    };\r\n\r\n    console.log(local_track);\r\n\r\n    //Since playback is essentially pausing, handle pause.\r\n    pause_tickers();\r\n\r\n    //Update UI.\r\n    update_track_UI();\r\n    update_controls_UI();\r\n    set_background_features(local_track.features);\r\n    update_background();\r\n  }\r\n\r\n  //prepare the player for playback.\r\n  function player_ready(device_id) {\r\n\r\n    /*If the player is ready after an error, remove error banner,\r\n    change to non-error state and re-initialise the UI*/\r\n    if (error_state) {\r\n      (\"#error_banner\").animate({ bottom: \"+=40px\" }, 500);\r\n      error_state = false;\r\n      reset_player();\r\n    }\r\n\r\n    //If we are ready for the first time.\r\n    if (first_load) {\r\n      first_load = false;\r\n      //TODO hide loader.\r\n    }\r\n\r\n    //Update some UI to give info to the user.\r\n    local_track.name = \"Ready To Play.\";\r\n    local_track.artists[0].name = \"Visit any Spotify player and choose 'Custom LED Player' as a device.\";\r\n\r\n  }\r\n\r\n  //returns a colour palette of given size from an image URL.\r\n  function get_palette_from_image(image_url, colour_count, done) {\r\n\r\n    //Define a pixel array, and a new image object.\r\n    var pixelArray = [];\r\n    var img = new Image();\r\n\r\n    //Allow for API-recieved image from cross-origin. Set URL to remote image.\r\n    img.crossOrigin = \"Anonymous\";\r\n    img.src = image_url;\r\n\r\n    //When the image is received from the origin, begin processing.\r\n    img.onload = function(image) {\r\n\r\n      //Get the colour palette from the image. Return.\r\n      done(paletteFromImage(image, colour_count));\r\n\r\n    }\r\n\r\n  }\r\n\r\n  //Function which rotates the gradent background at a speed defined by 'rotation_velocity'.\r\n  function update_background() {\r\n    if (angle > 360) angle = 0;\r\n    background.css(\"background\", \"linear-gradient(\" + angle + \"deg,\" +\r\n      \"rgba(\" + local_track.palette[0][0] + \",\" + local_track.palette[0][1] + \",\" + local_track.palette[0][2] + \",\" + background_opacity + \"),\" +\r\n      \"rgba(\" + local_track.palette[1][0] + \",\" + local_track.palette[1][1] + \",\" + local_track.palette[1][2] + \",\" + background_opacity + \"),\" +\r\n      \"rgba(\" + local_track.palette[2][0] + \",\" + local_track.palette[2][1] + \",\" + local_track.palette[2][2] + \",\" + background_opacity + \"),\" +\r\n      \"rgba(\" + local_track.palette[3][0] + \",\" + local_track.palette[3][1] + \",\" + local_track.palette[3][2] + \",\" + background_opacity + \"),\" +\r\n      \"rgba(\" + local_track.palette[4][0] + \",\" + local_track.palette[4][1] + \",\" + local_track.palette[4][2] + \",\" + background_opacity + \"),\" +\r\n      \"rgba(\" + local_track.palette[5][0] + \",\" + local_track.palette[5][1] + \",\" + local_track.palette[5][2] + \",\" + background_opacity + \")\");\r\n    angle += (rotation_velocity);\r\n  }\r\n\r\n  //Function to fetch a new access token from a given API endpoint (Async).\r\n  function getToken(done) {\r\n    console.log(\"getting new token\");\r\n    $.get(\"/auth/token/new\", function(data) {\r\n      if (data.error) {\r\n        if (data.error.reason == \"refresh_token_expired\") {\r\n          console.log(\"App has become unauthorised.\");\r\n          handle_error(\"refresh_token_expired\");\r\n        } else {\r\n          console.log(\"Unknown Error.\");\r\n        }\r\n      } else {\r\n        console.log(\"token success\");\r\n        done(data.access_token);\r\n      }\r\n    });\r\n  }\r\n\r\n  //start tickers for position seeker and rotating background.\r\n  function resume_tickers() {\r\n\r\n    //Start a rotation ticker (if not already started).\r\n    if (!rotator_ticker) rotator_ticker = window.setInterval(update_background, 17);\r\n\r\n    //Start a position ticker (if not already started).\r\n    if (!position_ticker) position_ticker = window.setInterval(update_position, 17);\r\n\r\n  }\r\n\r\n  //stop tickers for position seeker and rotating background.\r\n  function pause_tickers() {\r\n\r\n    //stop a rotation ticker (if not already stopped).\r\n    if (rotator_ticker) {\r\n      window.clearInterval(rotator_ticker);\r\n      rotator_ticker = null;\r\n    }\r\n\r\n    //stop a position ticker (if not already stopped).\r\n    if (position_ticker) {\r\n      window.clearInterval(position_ticker);\r\n      position_ticker = null;\r\n    }\r\n\r\n  }\r\n\r\n  //Function which progresses the position of the seeker bar.\r\n  function update_position() {\r\n    if (!error_state) {\r\n      if (prev_time + 50 < Date.now()) {\r\n        prev_time = Date.now();\r\n        //50 ms + 5ms to account for drift, measured to be around 5ms per update cycle.\r\n        local_track.position += 55;\r\n        update_controls_UI();\r\n      }\r\n    }\r\n  }\r\n\r\n  //convert a millisecond time into a pretty string.\r\n  function ms_to_string(ms) {\r\n\r\n    var string_time = \"\";\r\n\r\n    //Get hour, minuite and second values for the millisecond value.\r\n    var hour = parseInt((ms / (1000 * 60 * 60)) % 24);\r\n    var min = (parseInt((ms / (1000 * 60)) % 60)).toString();\r\n    var sec = (parseInt((ms / 1000) % 60)).toString();\r\n\r\n    //Account for single digit values. Convert to strings.\r\n    if (sec <= 9) sec = \"0\" + sec;\r\n    if (min <= 9) min = \"0\" + min;\r\n    if (hour <= 9) hour = \"0\" + hour;\r\n\r\n    //Account for zero hours.\r\n    if (hour != \"00\") string_time += (hour + \":\");\r\n\r\n    //Build and return the string format of the time.\r\n    string_time += (min + \":\" + sec);\r\n    return string_time;\r\n\r\n  }\r\n\r\n  //Handle errors by displaying a banner to the user.\r\n  function handle_error(error) {\r\n\r\n    //reset the player.\r\n    reset_player();\r\n\r\n    //Log the error to the console.\r\n    console.error(error);\r\n\r\n    //If we are not already in an error state, then change state.\r\n    if (!error_state) {\r\n\r\n      //Set the player to an error state (prevents updates)\r\n      error_state = true;\r\n\r\n      //Define and show an error message.\r\n      var message = \"Oops - Something went wrong (code: \" + error + \").\";\r\n      $(\"#error_banner p\").text(message);\r\n      $(\"#error_banner\").animate({ bottom: \"-=40px\" }, 1000);\r\n\r\n    }\r\n\r\n  }\r\n\r\n  //Function to visit the Spotify API and get track features using the 'features' endpoint\r\n  function get_features_from_track(track_object, done) {\r\n\r\n    var features = {};\r\n\r\n    //If a track is being played (over say an episode or advert) then features are avaliable.\r\n    if (track_object.type == \"track\") {\r\n\r\n      //Define endpoint URL\r\n      var audio_features_url = \"https://api.spotify.com/v1/audio-features/\" + track_object.id;\r\n\r\n      //Define AJAX call, adding the bearer token as authentication.\r\n      $.ajax({\r\n        url: audio_features_url,\r\n        type: \"GET\",\r\n        beforeSend: function(xhr) { xhr.setRequestHeader('Authorization', 'Bearer ' + token); },\r\n        success: function(data) {\r\n\r\n\r\n          //Update the local_track with track features.\r\n          features = {\r\n            \"tempo\": data.tempo,\r\n            \"energy\": data.energy,\r\n            \"loudness\": data.loudness,\r\n            \"valence\": data.valence\r\n          }\r\n\r\n          //prevent loudness being too quiet (for the purpose of the background opacity)\r\n          if (features.loudness < -15) features.loudness = -15;\r\n\r\n          //Scale the loudness between 0 and 1 (where 1 is the loudest);\r\n          features.loudness = Number(((features.loudness + 15) / 15).toPrecision(3));\r\n\r\n          console.log(\"features recieved\");\r\n\r\n          //done, so return to a callback.\r\n          done(features);\r\n\r\n        },\r\n        error: function() {\r\n          done(default_features());\r\n        }\r\n\r\n      });\r\n    } else {\r\n      done(default_features());\r\n    }\r\n  }\r\n\r\n  //A function which returns the default features of a track object.\r\n  function default_features() {\r\n    //resets for features.\r\n    return {\r\n      \"tempo\": 50,\r\n      \"energy\": 0.5,\r\n      \"loudness\": 0.5,\r\n      \"valence\": 0.5\r\n    }\r\n  }\r\n\r\n  //Set the features of the background based on the features of the track.\r\n  function set_background_features(features) {\r\n    rotation_velocity = Number(((features.tempo * features.energy) / 2500).toPrecision(2));\r\n    background_opacity = 0.5 + ((features.valence + features.loudness) / 4)\r\n    console.log(background_opacity);\r\n  }\r\n\r\n  //Show the control bar.\r\n  function show_controls() {\r\n\r\n    //Let the mouse movement lister know that the controls are no longer hidden.\r\n    controls_hidden = false;\r\n\r\n    //Stop any animations that the control bar might have from the hide_controls function.\r\n    $(\"#control_container\").stop();\r\n\r\n    //Reset the cursor to the default.\r\n    $(document.body).css(\"cursor\", \"default\");\r\n\r\n    //Set the control bar to full opacity.\r\n    $(\"#control_container\").css(\"opacity\", \"1\");\r\n\r\n  }\r\n\r\n  //Hide the control bar.\r\n  function hide_controls() {\r\n\r\n    //Let the mouse movement lister know that the controls are now hidden.\r\n    controls_hidden = true;\r\n\r\n    //Hide the cursor on the body.\r\n    $(document.body).css(\"cursor\", \"none\");\r\n\r\n    //Fade out the control bar over 1500ms using opacity.\r\n    $(\"#control_container\").animate({ opacity: 0 }, 1500);\r\n\r\n  }\r\n\r\n  //Function to ping the server and check for online connectivity.\r\n  function check_online() {\r\n\r\n    //Define AJAX call, adding the bearer token as authentication, to visit an arbituary endpoint.\r\n    $.ajax({\r\n      url: \"/ping\",\r\n      type: \"GET\",\r\n      complete: function(xhr, textStatus) {\r\n        //If status is 200, then we are online. Else, offline.\r\n        if (xhr.status != 0) {\r\n          //If we are recovering from an error, reload.\r\n          if (error_state) location.reload(true);\r\n        } else {\r\n          //Handle Error\r\n          handle_error(\"offline\");\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  //Mouse movement listener for the whole document.\r\n  $(document).mousemove(function() {\r\n\r\n    //On mouse move, cleae the inactivity timer.\r\n    window.clearTimeout(inactivity_timer);\r\n\r\n    //If the controls are hidden, then show them.\r\n    if (controls_hidden) show_controls();\r\n\r\n    //Reactivate the inactivity timer to wait for inactivity, and hide the controls is inactive.\r\n    inactivity_timer = window.setTimeout(hide_controls, activity_timeout);\r\n\r\n  });\r\n\r\n  //Ininitate the player UI components.\r\n  reset_player();\r\n\r\n});"]}