if (!pv) var pv = { map: function(t, n) { var r = {}; return n ? t.map(function(t, o) { return r.index = o, n.call(r, t) }) : t.slice() }, naturalOrder: function(t, n) { return t < n ? -1 : t > n ? 1 : 0 }, sum: function(t, n) { var r = {}; return t.reduce(n ? function(t, o, e) { return r.index = e, t + n.call(r, o) } : function(t, n) { return t + n }, 0) }, max: function(t, n) { return Math.max.apply(null, n ? pv.map(t, n) : t) } };
var MMCQ = function() { var t = 5,
    n = 8 - t,
    r = 1e3,
    o = .75;

  function e(n, r, o) { return (n << 2 * t) + (r << t) + o }

  function a(t) { var n = [],
      r = !1;

    function o() { n.sort(t), r = !0 } return { push: function(t) { n.push(t), r = !1 }, peek: function(t) { return r || o(), void 0 === t && (t = n.length - 1), n[t] }, pop: function() { return r || o(), n.pop() }, size: function() { return n.length }, map: function(t) { return n.map(t) }, debug: function() { return r || o(), n } } }

  function i(t, n, r, o, e, a, i) { var u = this;
    u.r1 = t, u.r2 = n, u.g1 = r, u.g2 = o, u.b1 = e, u.b2 = a, u.histo = i }

  function u() { this.vboxes = new a(function(t, n) { return pv.naturalOrder(t.vbox.count() * t.vbox.volume(), n.vbox.count() * n.vbox.volume()) }) }

  function c(t, n) { if (n.count()) { var r = n.r2 - n.r1 + 1,
        o = n.g2 - n.g1 + 1,
        a = n.b2 - n.b1 + 1,
        i = pv.max([r, o, a]); if (1 == n.count()) return [n.copy()]; var u, c, s, f, v = 0,
        h = [],
        p = []; if (i == r)
        for (u = n.r1; u <= n.r2; u++) { for (f = 0, c = n.g1; c <= n.g2; c++)
            for (s = n.b1; s <= n.b2; s++) f += t[e(u, c, s)] || 0;
          v += f, h[u] = v } else if (i == o)
          for (u = n.g1; u <= n.g2; u++) { for (f = 0, c = n.r1; c <= n.r2; c++)
              for (s = n.b1; s <= n.b2; s++) f += t[e(c, u, s)] || 0;
            v += f, h[u] = v } else
            for (u = n.b1; u <= n.b2; u++) { for (f = 0, c = n.r1; c <= n.r2; c++)
                for (s = n.g1; s <= n.g2; s++) f += t[e(c, s, u)] || 0;
              v += f, h[u] = v }
      return h.forEach(function(t, n) { p[n] = v - t }), l(i == r ? "r" : i == o ? "g" : "b") }

    function l(t) { var r, o, e, a, i, c = t + "1",
        s = t + "2",
        f = 0; for (u = n[c]; u <= n[s]; u++)
        if (h[u] > v / 2) { for (e = n.copy(), a = n.copy(), i = (r = u - n[c]) <= (o = n[s] - u) ? Math.min(n[s] - 1, ~~(u + o / 2)) : Math.max(n[c], ~~(u - 1 - r / 2)); !h[i];) i++; for (f = p[i]; !f && h[i - 1];) f = p[--i]; return e[s] = i, a[c] = e[s] + 1, [e, a] } } } return i.prototype = { volume: function(t) { var n = this; return n._volume && !t || (n._volume = (n.r2 - n.r1 + 1) * (n.g2 - n.g1 + 1) * (n.b2 - n.b1 + 1)), n._volume }, count: function(t) { var n = this,
        r = n.histo; if (!n._count_set || t) { var o, a, i, u = 0; for (o = n.r1; o <= n.r2; o++)
          for (a = n.g1; a <= n.g2; a++)
            for (i = n.b1; i <= n.b2; i++) index = e(o, a, i), u += r[index] || 0;
        n._count = u, n._count_set = !0 } return n._count }, copy: function() { var t = this; return new i(t.r1, t.r2, t.g1, t.g2, t.b1, t.b2, t.histo) }, avg: function(n) { var r = this,
        o = r.histo; if (!r._avg || n) { var a, i, u, c, s = 0,
          f = 1 << 8 - t,
          v = 0,
          h = 0,
          p = 0; for (i = r.r1; i <= r.r2; i++)
          for (u = r.g1; u <= r.g2; u++)
            for (c = r.b1; c <= r.b2; c++) s += a = o[e(i, u, c)] || 0, v += a * (i + .5) * f, h += a * (u + .5) * f, p += a * (c + .5) * f;
        s ? r._avg = [~~(v / s), ~~(h / s), ~~(p / s)] : (console.log("empty box"), r._avg = [~~(f * (r.r1 + r.r2 + 1) / 2), ~~(f * (r.g1 + r.g2 + 1) / 2), ~~(f * (r.b1 + r.b2 + 1) / 2)]) } return r._avg }, contains: function(t) { var r = this,
        o = t[0] >> n; return gval = t[1] >> n, bval = t[2] >> n, o >= r.r1 && o <= r.r2 && gval >= r.g1 && o <= r.g2 && bval >= r.b1 && o <= r.b2 } }, u.prototype = { push: function(t) { this.vboxes.push({ vbox: t, color: t.avg() }) }, palette: function() { return this.vboxes.map(function(t) { return t.color }) }, size: function() { return this.vboxes.size() }, map: function(t) { for (var n = this.vboxes, r = 0; r < n.size(); r++)
        if (n.peek(r).vbox.contains(t)) return n.peek(r).color; return this.nearest(t) }, nearest: function(t) { for (var n, r, o, e = this.vboxes, a = 0; a < e.size(); a++)((r = Math.sqrt(Math.pow(t[0] - e.peek(a).color[0], 2) + Math.pow(t[1] - e.peek(a).color[1], 2) + Math.pow(t[1] - e.peek(a).color[1], 2))) < n || void 0 === n) && (n = r, o = e.peek(a).color); return o }, forcebw: function() { var t = this.vboxes;
      t.sort(function(t, n) { return pv.naturalOrder(pv.sum(t.color), pv.sum(n.color)) }); var n = t[0].color;
      n[0] < 5 && n[1] < 5 && n[2] < 5 && (t[0].color = [0, 0, 0]); var r = t.length - 1,
        o = t[r].color;
      o[0] > 251 && o[1] > 251 && o[2] > 251 && (t[r].color = [255, 255, 255]) } }, { quantize: function(s, f) { if (!s.length || f < 2 || f > 256) return console.log("wrong number of maxcolors"), !1; var v, h, p, l, g, b, m = (v = s, b = new Array(1 << 3 * t), v.forEach(function(t) { p = t[0] >> n, l = t[1] >> n, g = t[2] >> n, h = e(p, l, g), b[h] = (b[h] || 0) + 1 }), b);
      m.forEach(function() {}); var d, x, w, C, y, _, M, z, I, k, E = (d = m, y = 1e6, _ = 0, M = 1e6, z = 0, I = 1e6, k = 0, s.forEach(function(t) { x = t[0] >> n, w = t[1] >> n, C = t[2] >> n, x < y ? y = x : x > _ && (_ = x), w < M ? M = w : w > z && (z = w), C < I ? I = C : C > k && (k = C) }), new i(y, _, M, z, I, k, d)),
        O = new a(function(t, n) { return pv.naturalOrder(t.count(), n.count()) });

      function q(t, n) { for (var o, e = 1, a = 0; a < r;)
          if ((o = t.pop()).count()) { var i = c(m, o),
              u = i[0],
              s = i[1]; if (!u) return void console.log("vbox1 not defined; shouldn't happen!"); if (t.push(u), s && (t.push(s), e++), e >= n) return; if (a++ > r) return void console.log("infinite loop; perhaps too few pixels!") } else t.push(o), a++ } O.push(E), q(O, o * f); for (var D = new a(function(t, n) { return pv.naturalOrder(t.count() * t.volume(), n.count() * n.volume()) }); O.size();) D.push(O.pop());
      q(D, f - D.size()); for (var P = new u; D.size();) P.push(D.pop()); return P } } }();

function paletteFromImage(t, n) { for (var r, o, e, a, i = (t = new CanvasImage(t.target)).getImageData().data, u = t.getPixelCount(), c = [], s = 0; s < u; s += 4) o = i[(r = 4 * s) + 0], e = i[r + 1], a = i[r + 2], i[r + 3] >= 125 && (o > 250 && e > 250 && a > 250 || c.push([o, e, a])); return t.removeCanvas(), MMCQ.quantize(c, n).palette() }
var CanvasImage = function(t) { this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), document.body.appendChild(this.canvas), this.width = this.canvas.width = t.width, this.height = this.canvas.height = t.height, this.context.drawImage(t, 0, 0, this.width, this.height) };
CanvasImage.prototype.getPixelCount = function() { return this.width * this.height }, CanvasImage.prototype.getImageData = function() { return this.context.getImageData(0, 0, this.width, this.height) }, CanvasImage.prototype.removeCanvas = function() { this.canvas.parentNode.removeChild(this.canvas) };